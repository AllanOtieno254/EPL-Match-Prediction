# -*- coding: utf-8 -*-
"""Premier league matches predictions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MTmQg8n14LA0HcrEyjkpAy0IiIMm0VtR

**Import Libraries and Load Dataset**
"""

# Importing necessary libraries
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score

# Mounting the drive to access the dataset
from google.colab import drive
drive.mount("/content/EPL_Matches_Prediction")

# Loading the dataset
matches = pd.read_csv("/content/EPL_Matches_Prediction/MyDrive/premier league matches.csv", index_col=0)
matches

"""**Basic Exploration and Inf**o"""

# Checking dataset information and basic statistics
matches.info()  # Displays data types, non-null counts, etc.
matches.describe()  # Shows summary statistics
matches.shape  # Displays number of rows and columns

"""**Data Exploration**"""

# Checking the distribution of teams
matches["team"].value_counts()

# Viewing records for a specific team (e.g., Liverpool)
matches[matches.team == "Liverpool"]

# Checking the distribution of match rounds
matches["round"].value_counts()

"""**Date Conversion**"""

# Converting the "date" column to datetime type
matches["date"] = pd.to_datetime(matches["date"])

# Confirming data types after conversion
matches.dtypes

"""**Encoding Categorical Features**"""

# Encoding categorical columns to numerical codes
matches["venue_code"] = matches["venue"].astype("category").cat.codes
matches["opp_code"] = matches["opponent"].astype("category").cat.codes

# Extracting hour from the time column
matches["hour"] = matches["time"].str.replace(":.+", "", regex=True).astype("int")

# Extracting the day of the week from the date
matches["day_code"] = matches["date"].dt.dayofweek

"""**Creating Target Column**"""

# Creating a target column where 'W' (win) is 1 and other results are 0
matches['target'] = (matches['result'] == 'W').astype('int')

# Viewing the first few rows to confirm the target column
matches.head()

""" **Splitting Data**"""

# Splitting data into training (before 2022) and testing (after 2022)
train = matches[matches["date"] < '2022-01-01']
test = matches[matches["date"] > '2022-01-01']

"""**Defining Predictors and Training RandomForest Model**"""

# Defining predictors
predictors = ['venue_code', 'opp_code', 'hour', 'day_code']

# Initializing Random Forest Classifier
rf = RandomForestClassifier(n_estimators=50, min_samples_split=10, random_state=1)

# Training the model using training data
rf.fit(train[predictors], train["target"])

"""**Predictions and Accuracy Check**"""

# Making predictions on the test set
preds = rf.predict(test[predictors])

# Checking model accuracy
acc = accuracy_score(test["target"], preds)
print(f"Accuracy: {acc}")

"""**Confusion Matrix and Precision Check**"""

# Creating a cross-tabulation to compare actual and predicted results
combined = pd.DataFrame(dict(actual=test['target'], prediction=preds))
pd.crosstab(index=combined["actual"], columns=combined["prediction"])

# Checking the precision score
precision = precision_score(test["target"], preds)
print(f"Precision: {precision}")

"""**Rolling Averages Function**"""

# Defining the function to calculate rolling averages
def rolling_averages(group, cols, new_cols):
    group = group.sort_values("date")  # Sorting data by date
    rolling_stats = group[cols].rolling(3, closed='left').mean()  # Calculating rolling averages
    group[new_cols] = rolling_stats  # Assigning new rolling average columns
    group = group.dropna(subset=new_cols)  # Dropping rows with missing values in new columns
    return group

"""**Applying Rolling Averages to a Single Team**"""

# Defining the columns for rolling averages
cols = ["gf", "ga", "sh", "sot", "dist", "fk", "pk", "pkatt"]
new_cols = [f"{c}_rolling" for c in cols]

# Applying the rolling averages function to a specific team (e.g., Manchester City)
grouped_matches = matches.groupby("team")
group = grouped_matches.get_group("Manchester City")
group = rolling_averages(group, cols, new_cols)

# Viewing the updated group with rolling averages
group.head()

"""**Applying Rolling Averages to the Whole Dataset**"""

# Applying the rolling averages function to all teams
matches_rolling = matches.groupby("team").apply(lambda x: rolling_averages(x, cols, new_cols))

# Dropping the team index level created by groupby
matches_rolling = matches_rolling.droplevel('team')
matches_rolling.index = range(matches_rolling.shape[0])

# Viewing the first few rows of the dataset with rolling averages
matches_rolling.head()

"""**Predictions with Rolling Averages**"""

# Function to make predictions using updated predictors including rolling averages
def make_predictions(data, predictors):
    train = data[data["date"] < '2022-01-01']  # Training data before 2022
    test = data[data["date"] > '2022-01-01']  # Testing data after 2022
    rf.fit(train[predictors], train["target"])  # Training the model
    preds = rf.predict(test[predictors])  # Making predictions on test data
    combined = pd.DataFrame(dict(actual=test["target"], prediction=preds), index=test.index)  # Comparing actual and predicted
    precision = precision_score(test["target"], preds)  # Calculating precision score
    return combined, precision

"""**Final Predictions with Updated Predictors**"""

# Adding rolling average columns to predictors and making final predictions
combined, precision = make_predictions(matches_rolling, predictors + new_cols)
print(f"Updated precision with rolling averages: {precision}")

combined

combined=combined.merge(matches_rolling[["date", "team", "opponent", "result"]], left_index=True, right_index=True)
combined.head(10)

"""**combining home and away predictions**"""

# Creating a custom dictionary class that inherits from Python's built-in dict
class MissingDict(dict):
    # The __missing__ method is called when a key is not found in the dictionary
    # Here, it simply returns the key itself if it's missing
    __missing__ = lambda self, key: key

# Creating a dictionary of team name mappings
# This maps long-form team names to their short versions
map_values = {
    "Brighton and Hove Albion": "Brighton",  # Mapping long form to shorter version
    "Manchester United": "Manchester Utd",  # Mapping Manchester United to Man Utd
    "Newcastle United": "Newcastle Utd",    # Mapping Newcastle United to short form
    "Tottenham Hotspur": "Tottenham",       # Mapping Tottenham Hotspur to Tottenham
    "West Ham United": "West Ham",          # Shortening West Ham United to West Ham
    "Wolverhampton Wanderers": "Wolves"     # Mapping Wolverhampton Wanderers to Wolves
}

# Instantiating the MissingDict class using the defined map_values
# This allows access to the shorter team names in map_values
# If a team is not in map_values, it returns the team name itself
mapping = MissingDict(**map_values)

# Accessing the mapped value for "West Ham United" from the mapping dictionary
# Since "West Ham United" exists in the map_values dictionary, it will return the mapped value "West Ham"
mapping["West Ham United"]  # Output: "West Ham"

# Accessing the mapped value for "Manchester United" from the mapping dictionary
# Since "Manchester United" exists in the map_values dictionary, it will return the mapped value "Manchester Utd"
mapping["Manchester United"]  # Output: "Manchester Utd"

# Creating a new column "new_team" in the 'combined' DataFrame
# This column is generated by mapping the values from the "team" column
# using the 'mapping' dictionary. It replaces full team names with shorter names.
combined["new_team"] = combined["team"].map(mapping)

# Displaying the updated DataFrame to check the new "new_team" column
combined

# Merging the 'combined' DataFrame with itself
# The merge happens on two columns: "date" and "new_team" from the left DataFrame
# and "date" and "opponent" from the right DataFrame.
# This merge combines rows where the 'new_team' played against the 'opponent' on the same date.
merged = combined.merge(combined, left_on=["date", "new_team"], right_on=["date", "opponent"])

# Displaying the resulting 'merged' DataFrame
merged

print(merged.columns)

# Looking for rows where one team was predicted to win (prediction_x = 1)
# and the opponent team was predicted to lose (prediction_y = 0).
# This helps us analyze when the model's predictions align with the actual match outcomes.

# We filter the 'merged' DataFrame for the following conditions:
# - 'prediction_x' is 1, indicating that team A was predicted to win.
# - 'prediction_y' is 0, indicating that team B was predicted to lose.

# The resulting DataFrame contains only the matches where team A was expected to win
# and team B was expected to lose.

# Now we want to check the actual outcomes for team A by looking at the 'actual_x' column.
# We use value_counts() to count how many times each outcome occurred in 'actual_x'.

# Important: Ensure 'actual_x' is in quotes to indicate that it's a column name.
# Replace 'actual_x' with the correct name if it differs in the DataFrame.

outcome_counts = merged[(merged["prediction_x"] == 1) & (merged["prediction_y"] == 0)]["actual_x"].value_counts()

# Print the outcome counts to see how many times team A won or lost in these predictions
print(outcome_counts)

#checking on our accuracy
27/40

import matplotlib.pyplot as plt
import seaborn as sns

# Create a count DataFrame for predictions and actual outcomes
prediction_outcomes = merged[(merged["prediction_x"] == 1) & (merged["prediction_y"] == 0)]["actual_x"].value_counts()

# Plotting
plt.figure(figsize=(8, 5))
sns.barplot(x=prediction_outcomes.index, y=prediction_outcomes.values, palette='Blues')
plt.title('Count of Actual Outcomes When Team A Was Predicted to Win and Team B to Lose')
plt.xlabel('Actual Outcome (1: Win, 0: Loss)')
plt.ylabel('Count')
plt.xticks(ticks=[0, 1], labels=['Loss', 'Win'])
plt.show()

from sklearn.metrics import confusion_matrix
import seaborn as sns

# Calculate confusion matrix
cm = confusion_matrix(test["target"], preds)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Predicted Loss', 'Predicted Win'],
            yticklabels=['Actual Loss', 'Actual Win'])
plt.title('Confusion Matrix')
plt.xlabel('Predicted Labels')
plt.ylabel('Actual Labels')
plt.show()

# Distribution of predictions
plt.figure(figsize=(8, 5))
sns.countplot(data=merged, x='prediction_x', palette='pastel')
plt.title('Distribution of Predictions for Team A (1: Win, 0: Loss)')
plt.xlabel('Prediction (1: Win, 0: Loss)')
plt.ylabel('Count')
plt.xticks(ticks=[0, 1], labels=['Loss', 'Win'])
plt.show()